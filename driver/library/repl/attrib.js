// NAME OF ATTRIBUTE SYSTEM: PASTA
// Dependency injection is 1 aspect of of Aspect oriented programming
// Pre-compiler #defines are 1 aspect of AOP
// Middleware is 1 type of AOP design
// Cloud computing is 1 aspect of infrastructure design
// // @Attributes are 1 aspect of Aspect orient programming
//   (^^^ That allows me to add aspect oriented programming)
//   (^^^ Lot's of languages have that, but then using 
//     that system to validate itself by making itself 
//     declarative is the dividing line that only I can
//     accomplish from 3 decades of programming and
//     learning a game Quake 3, i.e. brilliance, aka 
//     mind reading, aka brain-to-brain communication)


// TODO: adding all these silly comments so latter I can
//   make a markdown declaration that automatically converts 
//   science terms to wikipedia links and 1 declaration 
//   that automatically converts // comments + function 
//   into the jupyter notebook system with all @Attribute 
//   dependencies attached it's own declarative kernel system.

// Consequently, the structure/scaffolding for dependency
//    injection can be abstracted out to declarations i.e:

// @Ignore
test1(func => { test; script });
test2(func => {})
// becomes something more like:
({
	dev: 'test data',
	test: 'test data',
	stage: 'prod distilled'
})


// which generates all the functional branching at an API level
//   much like a .yml config file, parsing that instead would also
//   be declarative i.e. ({parseYml}) versus @Attribute({})/doAttributes in
//   an outer scope to the test environment context above.
// in order to add a level of complexity, @Attributes, we must remove
//   another order of complexity, functional branching (1 - 2) and 
//   function count (1 - 2) and project scaffolding, (1 - 2) real world
//   test cases in the component caller to test that the design works
//   a test / stage environment would be passed into the final context.
//   on node -e / compile / make. That removes a complexity from our
//   project file-system because I don't need a separate /test/ folder
//   the function usage actually becomes the test but it's also written
//   down for managers to see it.
// TODO: demonstrate seperate unit test file.


// The scaffolding for angular versus react
//   can all be designed away. Functional and logical branching
//   can all be declarative statements, which means in it's purest
//   form, the functions that remain 
//   (i.e. 1 or 2 per component, in and out, message / response) 
//   are actually the only test that generate a result.
// And the next component that uses the first component tests the
//   only inputs and outputs of the first component in order 
//   to generate the functionality it needs. Just like using
//   dependency injection to run a test, instead we're using
//   dependency injection to generate the program code from
//   the test inputs. Fuck unit-tests.
// I've always thought about code
//   this way, now I can finally design a learning-system
//   to explain why/how everybody else is making a mess.


// OKAY THEORY
//   A CPU INTERRUPT ADDS 1 VARIABLE
//   1 VARIABLE MAKES 2 BY COUNTING
//   A POSITION IN MEMORY INSTEAD OF
//   COUNTING ONLY A NUMBER.
//   2 VARIABLES MAKES INIFINITE VARIABLES
//   BY COUNTING ANOTHER MEMORY POSITION
//   USING THE FIRST MEMORY POSITION.

// MORE THEORY.
//   UNLIMITED MEMORY POSITIONS LOADS A
//   SINGLE PROGRAM STARTING POINT INTO
//   A LIST. FUNCTIONS ADD 1 LEVEL OF COMPLEXITY.
//   FUNCTION CALLS CREATE MINIATURE STACKS OF 
//   PROGRAMS, HENCEFORTH, THE SHELL.
//   THANKS TO ADA, WE HAVE OBJECT ORIENTED PROGRAMMING.
//   OBJECTS ADD 1 MORE LEVEL OF COMPLEXITY TO SOFTWARE
//   BY GROUPING FUNCTIONS TOGETHER LOGICALLY.

// STILL THEORY...
//   CPUs ARE COMPLEX. SOFTWARE IS COMPLEX.
//   CLASSES / COMPONENTS / MODULES / NAMESPACES / DEPENDENCY INJECTION
//   ALL ADD A HEIRARCHY OF COMPLEXITY TO PROGRAMS.
//   ENTER, PRE-COMPILER #IFs. SO GREAT, BUT DECLARATIVE
//   UNLESS USING SPECIAL EXTENSIONS. THE FACT THAT
//   PRE-COMPILER STATEMENTS ARE DECLARATIVE RATHER
//   THAN IMPERATIVE IS WHAT MAKES THEM SIMPLE ENOUGH
//   TO PUT IN BETWEEN CODE AND UNDERSTAND.
//   #IF DEFINED  // COMMENT ON WHY
//      ... DO SYSTEM CODE 
//   #ELSE 
//      ... DO OTHER CODE
//   #ENDIF
//
//   THIS LOOKS GREAT.

// THIS ADDS A NICE LITTLE ABILITY TO ADD ENVIRONMENTAL
//   CONTEXTUAL EXCEPTIONS IN CODE SUPPLEMENTED BY COMMENTS.
//   THE ONLY THING HOLDING THIS CONCEPT BACK IS ASPECTS.
// ASPECTS ARE LIKE COMPILER STATEMENTS THAT RUN AT
//   COMPILE TIME OR RUNTIME AND INSTEAD OF BEING ONLY
//   DECLARATIVE, THEY ARE ALSO FUNCTIONAL.
// HERE'S REALLY THE KEY POINT ON ASPECT ORIENTED PROGRAMMING
//   THE LEVEL OF COMPLEXITY THAT ASPECTS / ATTRIBUTES ADD
//   ARE DECLARATIVE BECAUSE IT IS A LANGUAGE STATEMENT/FEATURE.
//   INSTEAD OF COMPONENTS, CLASSES, AND DEPENDENCY INJECTION,
//   THOSE ARE ALL FUNCTIONAL COMPLEXITIES ADDED AT THE "SOFTWARE"
//   LEVEL AS OPPOSED TO "LANGUAGE" LEVEL. 
// THEY ARE OVERLY COMPLEX BECAUSE PEOPLE TURN "COMPONENTS"
//   INTO IMPLEMENTATION DETAILS. BUT BY USING ATTRIBUTES/ASPECTS
//   THAT SAME COMPLEXITY IS TURNED INTO A DECLARATIVE LANGUAGE
//   FEATURE, SO IT NEVER CHANGES BEHAVIOR. THE FACT THAT IT
//   NEVER CHANGES BEHAVIOR MAKES IT FINITE, WHICH MAKES IT
//   PROVABLE, WHICH MEANS YOU DON'T NEED TO WRITE UNIT-TESTS
//   FOR USING @ATTRIBUTES. FUCK UNIT-TESTS. THAT'S WHAT THIS
//   IS ALL ABOUT. NOT WRITING UNIT-TESTS.
// THERE WILL BE NOTHING LEFT TO TEST BECAUSE EVERY PROGRAM
//   WILL BE ONLY STATEMENTS AND IDEAS WITH NO FUNCTIONS OR
//   FRAMEWORKS OR ENVIRONMENTS.

// how the hell do I use attributes on the file that specifies how attributes work?
//   this is like taking the integral of logic and then testing it's limits.
// Obviously: 

// STEP 1, emit this function
// @Template
async function evaluate(topOfStack) {
	await topOfStack()
}

// integrating a program would be like applying dependency injection
//   to someone's existing code. this is integrating a programming
//   language. instead of taking the integral of a math equation
//   i'm taking the integral of syntax and logic. like differential
//   equations for software.
// but this is too simple, one more level of complexity and I 
//   should specify all the outputs of my attribute evaluations

// STEP 3, based on these declarations
// STEP 4, continue writing functionality using 2 
//    declarative lines (simple), @Attribute\nStatements

// ############ actual template code for attributes
// ```

// @Ignore
// do attribute events, do @Before events
// @Add(@Node,doAttributes)
// on response events, do @After calls
// @Add(@Node,doNode)
`node`

// ```
// ########### end template

// ^^^ Need to connect those two things together in 
//   one function using template system. the extra code
//   comments are for the reader and have nothing to do with
//   parsing attributes from code strings.

// STEP 2: by connecting this declarative style
// pretty loose attribute parser, parses attribs with 1 or more params
//  like @Function(myCustomBootstrap,doBootstrap)

// STEP 0: using this function to do STEP 1 - 4
// So, one function to read all attribute either
//   by parse text or loading acorn?

// ENTRY INTO ATTRIBUTE SYSTEM

// i.e. first is for bootstrapping
//   latter is for runtime use
// @Bootstrap
// @Add(@Add,add)
function add(nodeType, attribute, params) { 
	// ^^^ de-coupling attribute system from REPL object format. 

	// LOL, USING A BOOTSTRAP TEMPLATING SYSTEM TO  
	//   BOOTSTRAP LAMBDAS, IN ORDER TO BOOTSTRAP
	//   AN ATTRIBUTE SYSTEM ONTO JS, 
	//   TO MAKE 5-LINE NODE-GYP-STYLE 
	//   ENTRIES INTO MORE RELIABLE SYSTEMS?
	//   CODE POETRY. CODETRY.
	// CODE REVIEW, THIS IS A PRE-CURSOR TO LOADING
	//   THE CURRENT NODE'S ATTRIBUTES LOAD THE ACTUAL
	//   ATTRIBUTES FROM COMMENTS INTO THE NODE OBJECT
	let caseInsensitive = attribute.toLocaleLowerCase()
	if(typeof globalAttributes[caseInsensitive] == 'undefined') {
		globalAttributes[caseInsensitive] = []
	}
	globalAttributes[caseInsensitive].push(params)
	return globalAttributes
}


// return new code with attribute calls inserted into the code.
// CODE REVIEW, like Function.prototype.apply but one less context
function attribute(code) {
	console.log(globalAttributes)
	// [ '@add': [ [Function: add] ], '@remove': [ [Function: remove] ] ]

	if(typeof code == 'string') {
		// TODO: I'm just going to rewrite all the RegExps here in sequence
		//   to parse the above commands, even though I could write these 
		//   into template.js then bootstrap the cache on our own file, then
		//   use our own template system to parse our own @Attribute system I 
		//   linked to above which would prove it's own unit test. This part
		//   needs a unit test. I'm not going to write one. I refuse to learn.
		// A high-ranking security officer from Credit Karma told me he wants
		//   developers to stop writing vulnerabilities. This is the way. 
		//   It's not a pie-the-sky. It just takes commitment to not writing
		//   unit tests. LOL, invent a new language with a unit-test free side-effect.

		// TODO: REGEXP -> template(functions)
		// this level of abtraction is only to test our own system, the
		//   rest can be written and standard javascript using whatever
		//   level of attributes needed to keep the code small.


		// that we can use with the module loader in env.js like 
		//modules.exports = template({ doEval: (function () { 
		//   if(doAttributes) doCodeComplete(); eval(); onNode() }).toString() 
		//}) // that calls our attribute list instead, based on the next context
		//   outwards, in REPL it would be more attributes and queuing, and in
		//   env.js, eval(template()) called directly. In code-complete
		//   checker for lines / call expressions the doCodeComplete is added
		//   and records the symbols that we hit in each call branch.

		// TODO: recover regex to list comments right above functions
		//   pass into next fold

		// TODO RETURN:
		// TODO: need to return a list of evaluations that returns a list of
		//   functions for every attribute, in string/eval() mode each function
		//   can be called directly to get the effects of the attribute system.
	  //   TODO: but in REPL mode, another template would be applied to every
		//     eval() to call doNode() functions that affect the REPL stack
		//     structure instead. 100% responsibility isolation with 1 more level 
		//     of complexity, 1 list of polyfills specified below. 1 in / 1 out 
		//     function. This component follows all my new rules. Try < 30 lines of code.

		// TODO: attributed implications come from files formats following
		//   a specific predefined format, like:
		// @Styles
		// @HTML
		// @Controller
		//   for many frameworks, JSX-style file formats.
		// even jupyter could be generalized:
		// @Markdown
		// @Codeblock
		// @Results to guaruntee the JSON is alwayy generated in the same order
		// which means as long as there are utility functions that
		//   recognize that order from the function names or
		//   declarative attributed object templates, the attributes
		//   can be ommitted entirely because the symbology of the
		//   syntax follows a specific pattern.
		// i.e.
		// @Setup
		// @DoTest
		// @Results
		// Why would I write do(it()) when it never worked without
		//   it? it's redundant, just assume it's was there in the first place.

		// TODO: use functional-comment attributes to detect
		//   regex (var,let) desclarations to get list(cache) working
		//   use regex to find // @Attribute\n({\n\n}) with a copied...
		//   TODO: EDGE-CASE, balanced-brackes if preceeded by (parens)?
		//      BAH! can't find equal curly brackets inside of strings
		//      (TODO: does balanced-brackets not work within strings/templates?)
		//      without the language lexer! Need more WASMs >:Z

	} else 
	// TODO: also do using acorn. 
	if(typeof acorn != 'undefined') {
				
		// this runs 1 time to load attributes for the 
		//   statement for the whole program
		//   i.e. if a function is called multiple times
		//   it does not load it's own attributes multiple 
		//   times, only once. if attributes need to change
		//   every time a function is called, an attribute
		//   should be created that changes the list of
		//   runContext.attributes. i.e. @Add(@Function, _changeAttribs)

		abstractNode.attributes = []
		for(let i = 0; 
			i < comments.length; 
			++i) {
			let match = MATCH_ATTRIBUTE.exec(
					comments[abstractNode.loc.start][i])

			if(!match) { continue }
			let attribName = match[1].toLocaleLowerCase()
					.replace(/^@/, '')
			// TODO: load attributes from comments into nodes
			// on instructions
			// actually to do the attribute thing
			// TODO: @Node attribute also fires
			//   doAttribute within the predicate frame
			if(typeof runContext.attributes[attribName] == 'undefined') {
				runContext.attributes[attribName] = []
			}
			runContext.attributes[attribName].push([
				match[1], 
				[match[2]].concat(match[3].split(',')
					.map(function(attr) { return attr.trim() })),
				[comments[abstractNode.loc.start][i]]
					.concat(Array.from(match))
			])
		}

		/*
		runContext.programCallstack.push({
			type: 'Evaluate',
			value: doNodeAttributes
					.bind(null, runContext, abstractNode,
							// for convenience
							runContext.comments[abstractNode.loc.start])
		})

		if(typeof runContext.attributes == 'undefined') {
			runContext.attributes = []
			// TODO: do
		}

		if(typeof abstractNode.attributes != 'undefined') {
			return // prevent recursion
		}

		// TODO: add C# static Class loader feature here

		// TODO: add / remove
		for(let j = 0;
			j < runContext.attributes[attribName].length;
			j++) {

			if( == 'add' || 'remove') {

				// push onto runContext.attributes
				continue
			}

			// push only abstractNode.attributes
		}
		*/

	}

}

// @Add(@Remove,remove)
function remove(attributes, nodeType, attribute, params) {
	if(typeof attributes[caseInsensitive] == 'undefined') {
		return
	}
	let attributeIndex = attributes[caseInsensitive]
		.indexOf(params)
	if(attributeIndex > -1) {
		attributes[caseInsensitive].splice(attributeIndex, 1)
	}
	return attributes
}




// @Test
({
	// TODO: match only the comments right before functions
	// TODO: match all attributes in comments
	topOfStack: MATCH_ATTRIBUTE.exec(comment), // TODO: only one @attr per line comment
	// TODO: one more match to match any word with an @attr above it, to match objects
	//   variables, parameters, etc...
})

// TODO: use attribute system on this list below to define
//   and a template to replace function calls with calls
//   to it's own attributes.
// @Template(balanced)
({
	eval: (/[\s\.](eval|onEval)\s*\(/gi),
	// TODO:
	balanced: ')',
})



// #############  THIS SHOULD BE ENOUGH TO GET REPL GOING
// #############  FOR MORE RELIABLE SYNTAX EVALUATIONS USING
// #############  THE SAME DECLARATIVE SYSTEM AND 5 LINES OF CODE.




// TODO: add attributes to another language that doesn't have them
//   using this system on itself. ie function attributes(antlr) {}

({


})
// TODO: add comments to a language that doesn't have comments?
//   then add attributes to that with above?
// TODO: write the test.js validation using the attribute system
//   on the attribute system, i.e. write the test.js runner with @Attribute({}) declarations

// TODO: make this a DFA animation showing every node type
//   in a long list and shifting between positions
//   should go nicely with the vertical line highlighter.

({


})

// I THINK THIS FULLY CAPTURES WHAT I WAS IMAGINING
/* 
this list above adds attributes via @add(@function,doFunction)
		to abstractNode.attributes only once it loads this list.
the loops below add call statements for attributes in the order of

using @function for example, but this runs the 
	same for every symbol, ie.e @literal @identifier @codeblock
@add(@function, doOnce) - means run on attribute load - one time
@add(function, doFunction) - means run on every function node - this one is implied

- one time only for each node type
		@add/@remove(@function, doCustomFunction) - runContext.attributes
		@dev/@myCustomAttribute - abstractNode.attributes
	push doFunctionAttribute  - first time only
	push all on to stack (@function -> doCustomFunction)  - one time only

- runs every time for a node
	push doNode - Evaluate
	push doFunction
	push all (abstractNode.attributes) i.e. @auth/@public
	push all (runContext.attributes['function']) - without @ 
																	means run on node, not run on attribute loading

THIS ENSURES PROGRAMMATIC CONTROL OVER EVERY STEP USING CALLBACKS
basically:
		@runFunction() callbacks - once
		doFunctionAttribute()
		
		runFunction callbacks - every node
		@user @attributes - all user defined attributes for node every call
		doFunction - load params / body

		doNode - start on* callback events

TODO: add @before, @after as POC

*/


// TODO: write in a way we can add attribution to other things like MP3s
// TODO: look up attribs in library to figure out
//   what REPL functions to call for symbols, i.e.
//   one modest size function to handle all loop
//   types, @for,@do,@dowhile all on the doLoop()
// TODO: lookup function in global
// TODO: lookup function in library
// TODO: weird, how to collapse and make @Identifier lookups
//   also use the same doLibraryLookup call here? is this
//   art abstract enough for everyone? lol
// TODO: only 1 time, convenience for loading more attributes

// CODE REVIEW, USING THESE LITTLE INTERNAL RECURSIVE LOOPS SHOULD SHOW
//   UP AS LEAVES IN A CODE REVIEW TOOL, BUT IT ALLOWS THE FUNCTION ABOVE
//   TO MAINTAIN ITS PURPOSE OF LOADING THE CURRENT NODES ATTRIBUTES ONTO STACK
//   DESPITE HAVING A PRE-CURSOR TO THAT; I.E. ACTUALLY LOADING THE ATTRIBUTES


// TODO: combine entire attribute feature into 2 functions just like doEval()


function doNode(abstractNode) {
	// TODO:  if abstractNode has attributes
	// TODO: make this implicit using the look below?
	// this would be a good place to put `static` loaders
	//   i.e. doFunctionAttribute() { attributes.push('static', loadLibraries) }
	// This runs every time the call is hit
	// CODE REVIEW, I DON'T LIKE USING `this.`, implement static "prototype" functions from C#
	// TODO: micro manage call stack / return stack, that's all
	// TODO: push Attributes to stack
	// do instruction
	// this runs every time the call is hit
	// this runs 1 time for each node in a program to load @After node functions
	// TODO: @After calls
	// TODO: micro manage call stack / return stack, that's all
	// TODO: push Attributes to stack

	for(let i = 0; 
		i < comments[abstractNode.loc.start].length; 
		++i) {
	let match = MATCH_ATTRIBUTE.exec(
			comments[abstractNode.loc.start][i])
}

// this would be a good place to put `static` loaders
//   i.e. on
if(typeof globalThis['on' + abstractNode.type + 'Attribute']) {
	programCallstack.push({
		type: 'Evaluate',
		value: globalThis['on' + abstractNode.type+ 'Attribute']
				.bind(null, abstractNode)
	})
}
}

// #################### BOTTOM_HALF

/*
// CODE REVIEW, FINALLY FOUND A WAY TO TEST A PROGRAMMING LANGUAGE FOR FEATURE COMPLETENESS
//   ADDING TO THIS SWITCH LIST, AND USING THE PROGRAM COUNTER, IT BREAKS EVERY TIME A
//   POLYFILL IS NOT MANIPULATING THE PROGRAM STACK CORRECTLY.
//   THIS WAY I CAN ADD ASPECTS (BEFORE/AFTER) CALLS LIKE TRACKING TIMERS
//   AND GAURANTEE THE STACK DOESN'T GET CORRUPTED.
// TODO: NEED TO DO THE SAME THING FOR RETURN STATEMENTS, EVERY EXPRESSION
//   PUSHES A RETURN VALUE, AND THEN POP IT OFF IF IT ISN'T USED IN THE NEXT STATEMENT
//   CAN ONLY HAVE 1 THING IN RETURN STACK WHEN RETURN STATEMENT IS EVALUATED
//   THAT MEANS ALL THE OTHER TOKEN TYPES CLEARED THE EXTRA CALL FRAME VALUES
//   THEY STORED (I.E. LEFT/RIGHT)
// CODE REVIEW, OH GOD, SO MUCH LESS CODE. IMAGINE REPLACING ALL OF BABEL
//   GULP, THE WHOLE NODE ECOSYSTEM CAN BE EVOLVED WITH SO MUCH SMALLER
//   VISITOR CODE. NOW ADDING IN MY SYNTAX SERVICE, I CAN APPEND ANY FUNCTION
//   IN THE NODE API WITH MY OWN PRECURSORS, IMAGINE CONTEXTUALIZED FILE-SYSTEMS
// WHERE THE SAME CODE RUNS BUT IN ONE ENVIRONMENT IT'S READING FROM MEMFS, AND
//   ONE ENVIRONMENT IT'S READING FROM ZFS. LIKE DEPENDENCY INJECTION ON STEROIDS.
//   IT'S LIKE THE ASPECTS CHANGE DEPENDENCIES ON THE FLY.

const PROGRAM_EXPRESSIONS = [
	'Program', 'Unsyntactic', 'BreakStatement', 'ContinueStatement',
	'DebuggerStatement', 'DoWhileStatement', 'VariableDeclaration', 'IfStatement',
	'ReturnStatement', 'SwitchCase', 'SwitchCase', 'SwitchStatement',
	'ThrowStatement', 'CatchClause', 'TryStatement', 'VariableDeclaration',
	'WhileStatement', 'WithStatement', 'EmptyStatement', 'LabeledStatement',
	'ExpressionStatement', 'BlockStatement', 'ForStatement', 'ForInStatement',
	'ForOfStatement', 'VariableDeclarator', 'FunctionDeclaration', 'FunctionExpression',
	'ClassBody', 'ClassDeclaration', 'ClassExpression', 'Identifier',
	'MethodDefinition', 'PropertyDefinition', 'StaticBlock', 'ExportAllDeclaration',
	'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExportSpecifier', 'ImportDeclaration',
	'ImportDefaultSpecifier', 'ImportNamespaceSpecifier', 'ImportSpecifier', 'SpreadElement',
	'RestElement', 'ArrayPattern', 'AssignmentPattern', 'SequenceExpression',
	'AssignmentExpression', 'ConditionalExpression', 'LogicalExpression', 'BinaryExpression',
	'UpdateExpression', 'UnaryExpression', 'UpdateExpression', 'ChainExpression',
	'MemberExpression', 'CallExpression', 'TaggedTemplateExpression', 'Super',
	'ThisExpression', 'Literal', 'ArrayExpression', 'ImportExpression',
	'MetaProperty', 'Literal', 'SequenceExpression', 'ParenthesizedExpression',
	'MetaProperty', 'NewExpression', 'TemplateElement', 'TemplateLiteral',
	'ObjectPattern', 'ObjectExpression', 'RestElement', 'SpreadElement',
	'Property', 'FunctionExpression', 'ArrowFunctionExpression', 'Identifier',
	'PrivateIdentifier', 'YieldExpression', 'AwaitExpression',
]

*/



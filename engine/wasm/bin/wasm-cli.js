// I TRIED WASM-CLI OFFICIAL AND IT WAS A HORRIBLE EXPERIENCE
//   I THINK IT MIGHT BE EXPECTING PROGRAMS BUNDLED WITH EMSCRIPTEN
//   THIS IS MUCH SHORTER CODE TO GET A WASM TO RUN THAN EMSCRIPTEN


// remove these references for web and emulate
const fs = require('fs')
const path = require('path')
const FS = require('../sys_fs.js')
const {Sys_Mkdirp, ST_FILE} = FS
const {
	initEnvironment,
	initWasm,
	updateEnvironment
} = require('../sys_wasm.js')
const {stringToAddress, addressToString} = require('../sys_std.js')


let foundFiles = []
// TODO: compare to initWasm() and make match
// TODO: move to sys_cli.js?
async function readAll() {
	for(let i = 0; i < foundFiles.length; i++) {
		let sourceName = foundFiles[i]
		if(sourceName.startsWith('/base')
			|| sourceName.startsWith('/home'))
			sourceName = sourceName.substring('/base'.length)
		if(sourceName[0] == '/')
			sourceName = sourceName.substring(1)

		if(fs.existsSync(path.dirname(sourceName))) {
			Sys_Mkdirp(stringToAddress(path.dirname(sourceName)))
		}

		if(!fs.existsSync(sourceName)) {
			continue
		}
		// TODO: THIS IS THE FUNCTIONAL PART OF THE FILE SYSTEM THAT I WANT TO REWRITE 
		//   BETWEEN PLATFORMS, < 10 FUCKING LOC.
		let inFileBytes = new Uint8Array(
			fs.readFileSync(sourceName, 'binary').toString()
					.split('').map(c => c.charCodeAt(0)))
		FS.virtual[sourceName] = {
			timestamp: new Date(),
			mode: FS.FS_FILE,
			contents: inFileBytes
		}
	}
}


let errTimer
let outTimer
function Sys_notify(ifile, path, fp) {
	if(fp == HEAPU32[stderr>>2]) {
		if(!errTimer) { // because it will happen later
			errTimer = setTimeout(function () {
				errTimer = null
				console.error(Array.from(ifile.contents)
					.map(function (c) { return String.fromCharCode(c) }).join(''))
				ifile.contents = new Uint8Array()
			}, 100)
		}
	} else
	if(fp == HEAPU32[stdout>>2]) {
		if(!outTimer) {
			outTimer = setTimeout(function () {
				outTimer = null
				console.log(Array.from(ifile.contents)
					.map(function (c) { return String.fromCharCode(c) }).join(''))
				ifile.contents = new Uint8Array()
			}, 100)
		}
	}

}


let SYS = {
	exited: false,
	Sys_Exit: Sys_Exit,
	Sys_exec: Sys_exec,
	Sys_execv: Sys_exec,
	Sys_notify: Sys_notify,
}

function Sys_Exit(e) {
	if(e) {
		debugger
		throw new Error('Exited: ' + e)
	} else {
		SYS.exited = true
	}
}

let wasmFile

async function initProgram(startArgs) {
	let bytes = new Uint8Array(fs.readFileSync(wasmFile))
	let ENV = initEnvironment(SYS) // TODO: something todo with Z_Malloc in ListFiles?
	let program = await initWasm(bytes, ENV)
	//console.log(program.instance.exports)
	updateEnvironment(program, ENV)
	await readAll()
	let originalKeys = Object.keys(FS.virtual)
	try {
		Sys_Mkdirp(stringToAddress('tmp'))
		_start(startArgs.length + 1, 
			stringsToMemory([ wasmFile ].concat(startArgs)))
	} catch (e) {
		if(!SYS.exited || e.message != 'unreachable') {
			SYS.exited = true
			throw e
		}
	}

	// TODO: some sort of inotify detection API that makes it easy to emit
	//   --emit-default leads to a function that writes anything from Sys_notify
	//   --emit-cloud, --emit-remote, --emit-brotli? GCP only works with pre-deflated files
	let newKeys = Object.keys(FS.virtual)
	console.log(newKeys)
	for(let i = 0; i < newKeys.length; i++) {
		if(!originalKeys.includes(newKeys[i])
			&& (FS.virtual[newKeys[i]].mode >> 12) == ST_FILE
		) {
			if(fs.existsSync(path.dirname(newKeys[i]))
				&& !fs.existsSync(newKeys[i])
				
			) {
				console.log('Emitting: ', newKeys[i])
				// file was definately generated by this script
				fs.writeFileSync(newKeys[i], FS.virtual[newKeys[i]].contents)
			}
		}
	}

}


function Sys_exec(program, args) {
  // try to find and execute wasm in same context like INSECURE DLLs in Windows
  // we only have inmemory FS and specific system functions, there isn't much
  //   anyone can do from here on native to break out of nodejs sandbox
	let programStr = addressToString(program)
	if(programStr.length < 1) {
		return 1
	}
	if(!fs.existsSync(programStr) 
		|| !fs.statSync(programStr).isFile()) {
		programStr += '.wasm'
	}
	if(!fs.existsSync(programStr)) {
		throw new Error('Command not found: ' + programStr)
	}

	// skip arg[0] = program name, will fill it in when it resolves
	//   this is always a system level decision, I think
	let varg = args+4
	let startArgs = []
	while(HEAPU32[varg>>2]!=0) {
		startArgs.push(addressToString(HEAPU32[varg>>2]))
		varg+=4
	}
	wasmFile = programStr
	debugger
	initProgram(startArgs)
		// THIS IS WHAT HAPPENS WHEN A CHILD PROCESS DIES
		.catch(e => {
			// TODO: send something back to LCC?
			console.error(e)
			Sys_Exit(1)
		})
	return 0 // INIT OK! POSIX WOOOO!
}

let startArgs = []
let runProgram = false
for(let i = 0; i < process.argv.length; i++) {
  let a = process.argv[i]
  if(a.match(__filename)) {
    runProgram = true
  } else if(a == '--') {
		continue
	} else if(a == 'node' || a.endsWith('/node')) {
		continue
	} else if(a.includes('.wasm')) {
		if(fs.existsSync(a)) {
			wasmFile = a
		} else if (path.join(__dirname, '../../../build/release-wasm-js/', a)) {
			wasmFile = path.resolve(path.join(__dirname, '../../../build/release-wasm-js/', a))
		} else {
			throw new Error('Wasm not found: ' + a)
		}
	} else if (a) {
		startArgs.push(a)
		if(fs.existsSync(a) || (
			path.dirname(a).length > 1 && fs.existsSync(path.dirname(a)))
		) {
			foundFiles.push(a)
		} else {
			//console.log('WARNING: File not found: ' + a)
		}
  }
}

if(runProgram) {
	if(!wasmFile) {
		throw new Error('Must specify a .wasm to run!')
	} else {
		initProgram(startArgs)
			.catch(e => {
				console.error(e)
				process.exit(1)
			})
	}
}


module.exports = initProgram

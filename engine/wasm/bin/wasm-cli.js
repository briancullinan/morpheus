// I TRIED WASM-CLI OFFICIAL AND IT WAS A HORRIBLE EXPERIENCE
//   I THINK IT MIGHT BE EXPECTING PROGRAMS BUNDLED WITH EMSCRIPTEN
//   THIS IS MUCH SHORTER CODE TO GET A WASM TO RUN THAN EMSCRIPTEN


// remove these references for web and emulate
const fs = require('fs')
const path = require('path')
const FS = require('../sys_fs.js')
const {Sys_Mkdirp} = FS
const {
	initEnvironment,
	initWasm,
	updateEnvironment
} = require('../sys_wasm.js')
const {stringToAddress, addressToString} = require('../sys_std.js')


let foundFiles = []
// TODO: compare to initWasm() and make match
// TODO: move to sys_cli.js?
async function readAll() {
	for(let i = 0; i < foundFiles.length; i++) {
		let sourceName = foundFiles[i]
		if(sourceName.startsWith('/base')
			|| sourceName.startsWith('/home'))
			sourceName = sourceName.substring('/base'.length)
		if(sourceName[0] == '/')
			sourceName = sourceName.substring(1)

		if(!fs.existsSync(sourceName)) {
			continue
		}
		// TODO: THIS IS THE FUNCTIONAL PART OF THE FILE SYSTEM THAT I WANT TO REWRITE 
		//   BETWEEN PLATFORMS, < 10 FUCKING LOC.
		let inFileBytes = new Uint8Array(
			fs.readFileSync(sourceName, 'binary').toString()
					.split('').map(c => c.charCodeAt(0)))
		FS.virtual[sourceName] = {
			timestamp: new Date(),
			mode: FS.FS_FILE,
			contents: inFileBytes
		}
	}
}

function Sys_exec(program, args) {
	let programStr = addressToString(program)
	debugger
}


function Sys_Exit(e) {
	if(e) {
		throw new Error('Exited: ' + e)
	} else {
		SYS.exited = true
	}
}

let wasmFile

async function initProgram(startArgs) {
	let bytes = new Uint8Array(fs.readFileSync(wasmFile))
	let ENV = initEnvironment({
		Sys_Exit: Sys_Exit,
		Sys_exec: Sys_exec,
		Sys_execv: Sys_exec,
	}) // TODO: something todo with Z_Malloc in ListFiles?
	let program = await initWasm(bytes, ENV)
	//console.log(program.instance.exports)
	updateEnvironment(program, ENV)
	await readAll()
	let originalKeys = Object.keys(FS.virtual)

	try {
		debugger
		_start(startArgs.length + 1, 
			stringsToMemory([ wasmFile ].concat(startArgs)))
	} catch (e) {
		if(!SYS.exited || e.message != 'unreachable') {
			Sys_Exit(1)
			throw e
		}
	}

	// TODO: some sort of inotify detection API that makes it easy to emit
	//   --emit-default leads to a function that writes anything from Sys_notify
	//   --emit-cloud, --emit-remote, --emit-brotli? GCP only works with pre-deflated files
	let newKeys = Object.keys(FS.virtual)
	console.log(newKeys)
	for(let i = 0; i < newKeys.length; i++) {
		if(!originalKeys.includes(newKeys[i])) {
			if(fs.existsSync(path.dirname(newKeys[i]))
				&& !fs.existsSync(newKeys[i])) {
				// file was definately generated by this script
				fs.writeFileSync(newKeys[i], FS.virtual[newKeys[i]].contents)
			}
		}
	}

}


let startArgs = []
let runProgram = false
for(let i = 0; i < process.argv.length; i++) {
  let a = process.argv[i]
  if(a.match(__filename)) {
    runProgram = true
  } else if(a == '--') {
		continue
	} else if(a == 'node' || a.endsWith('/node')) {
		continue
	} else if(a.includes('.wasm')) {
		if(fs.existsSync(a)) {
			wasmFile = a
		} else if (path.join(__dirname, '../../../build/release-wasm-js/', a)) {
			wasmFile = path.resolve(path.join(__dirname, '../../../build/release-wasm-js/', a))
		} else {
			throw new Error('Wasm not found: ' + a)
		}
	} else if (a) {
		startArgs.push(a)
		if(fs.existsSync(a) || (
			path.dirname(a).length > 1 && fs.existsSync(path.dirname(a)))
		) {
			foundFiles.push(a)
		//} else if (path.join(process.cwd, a)) {
		//	foundFiles.push(path.join(process.cwd, a))
		} else {
			//console.log('WARNING: File not found: ' + a)
		}
  }
}

if(runProgram) {
	if(!wasmFile) {
		throw new Error('Must specify a .wasm to run!')
	} else {
		initProgram(startArgs)
			.catch(e => {
				console.error(e)
				process.exit(1)
			})
	}
}


module.exports = initProgram

// I TRIED WASM-CLI OFFICIAL AND IT WAS A HORRIBLE EXPERIENCE
//   I THINK IT MIGHT BE EXPECTING PROGRAMS BUNDLED WITH EMSCRIPTEN
//   THIS IS MUCH SHORTER CODE TO GET A WASM TO RUN THAN EMSCRIPTEN


// remove these references for web and emulate
const fs = require('fs')
const path = require('path')
const FS = require('../sys_fs.js')
const {Sys_Mkdirp, ST_FILE} = FS
const {
	initEnvironment,
	initWasm,
	updateEnvironment,
	initProgram,
	initAll,
} = require('../sys_wasm.js')
const {stringToAddress, addressToString} = require('../sys_std.js')


let foundFiles = []
// TODO: compare to initWasm() and make match
// TODO: move to sys_cli.js?
function readAll() {

	for(let i = 0; i < foundFiles.length; i++) {
		let sourceName = foundFiles[i]
		if(sourceName.startsWith('/base')
			|| sourceName.startsWith('/home'))
			sourceName = sourceName.substring('/base'.length)
		if(sourceName[0] == '/')
			sourceName = sourceName.substring(1)

		if(fs.existsSync(path.dirname(sourceName))) {
			Sys_Mkdirp(stringToAddress(path.dirname(sourceName)))
		}

		if(!fs.existsSync(sourceName)) {
			continue
		}
		// TODO: THIS IS THE FUNCTIONAL PART OF THE FILE SYSTEM THAT I WANT TO REWRITE 
		//   BETWEEN PLATFORMS, < 10 FUCKING LOC.
		let inFileBytes = new Uint8Array(
			fs.readFileSync(sourceName, 'binary').toString()
					.split('').map(c => c.charCodeAt(0)))
		FS.virtual[sourceName] = {
			timestamp: new Date(),
			mode: FS.FS_FILE,
			contents: inFileBytes
		}
	}
}


let errTimer
let outTimer
function Sys_notify(ifile, path, fp) {
	if(fp == HEAPU32[stderr>>2]) {
		if(!errTimer) { // because it will happen later
			errTimer = setTimeout(function () {
				errTimer = null
				console.error(Array.from(ifile.contents)
					.map(function (c) { return String.fromCharCode(c) }).join(''))
				ifile.contents = new Uint8Array()
			}, 100)
		}
	} else
	if(fp == HEAPU32[stdout>>2]) {
		if(!outTimer) {
			outTimer = setTimeout(function () {
				outTimer = null
				console.log(Array.from(ifile.contents)
					.map(function (c) { return String.fromCharCode(c) }).join(''))
				ifile.contents = new Uint8Array()
			}, 100)
		}
	}

}


let SYS = {
	exited: false,
	Sys_Exit: Sys_Exit,
	Sys_notify: Sys_notify,
}

function Sys_Exit(e) {
	if(e) {
		debugger
		throw new Error('Exited: ' + e)
	} else {
		SYS.exited = true
	}
}


function parseCommandLine() {
	let wasmFile
	let startArgs = []
	let runProgram = false
	for(let i = 0; i < process.argv.length; i++) {
		let a = process.argv[i]
		if(a.match(__filename)) {
			runProgram = true
		} else if(a == '--') {
			continue
		} else if(a == 'node' || a.endsWith('/node')) {
			continue
		} else if(a.includes('.wasm')) {
			if(fs.existsSync(a)) {
				wasmFile = a
			} else if (path.join(__dirname, '../../../build/release-wasm-js/', a)) {
				wasmFile = path.resolve(path.join(__dirname, '../../../build/release-wasm-js/', a))
			} else {
				throw new Error('Wasm not found: ' + a)
			}
			startArgs.push(wasmFile)
			foundFiles.push(wasmFile)
		} else if (a) {
			startArgs.push(a)
			if(fs.existsSync(a) || (
				path.dirname(a).length > 1 && fs.existsSync(path.dirname(a)))
			) {
				foundFiles.push(a)
			} else {
				//console.log('WARNING: File not found: ' + a)
			}
		}
	}


	if(runProgram) {
		if(!wasmFile) {
			throw new Error('Must specify a .wasm to run!')
		} else {
			readAll()
			initAll(startArgs, {
				SYS: SYS
			}).catch(e => {
				console.error(e)
				process.exit(1)
			})

			// TODO: some sort of inotify detection API that makes it easy to emit
			//   --emit-default leads to a function that writes anything from Sys_notify
			//   --emit-cloud, --emit-remote, --emit-brotli? GCP only works with pre-deflated files
			let newKeys = Object.keys(FS.virtual)
			console.log(newKeys)
			for(let i = 0; i < newKeys.length; i++) {
				if(!originalKeys.includes(newKeys[i])
					&& (FS.virtual[newKeys[i]].mode >> 12) == ST_FILE
				) {
					if(fs.existsSync(path.dirname(newKeys[i]))
						&& !fs.existsSync(newKeys[i])
						
					) {
						console.log('Emitting: ', newKeys[i])
						// file was definately generated by this script
						fs.writeFileSync(newKeys[i], FS.virtual[newKeys[i]].contents)
					}
				}
			}

		}
	}

}


if(typeof module != 'undefined') {
	parseCommandLine()
}


module.exports = initProgram
